\subsection{Implementation}

Formålet med dette afsnit er at gå fra vores design til kode.

\subsubsection{Søgning i krediteringer}%
\label{ssub:sogning_i_krediteringer}

Søgninger i krediteringer baserer sig på brugsmønster B03. Operationskontrakten
for dette brugsmønster ses i tabel \ref{tab:OperationsKontraktB03}. Det
udspecificerede sekvensdiagram ses på figur \ref{fig:B03OSDDesign}.

Fra \texttt{Menu.fxml} kaldes \texttt{submitSearch()} i controlleren
\texttt{MenuController}, ved tryk på søgeknappen. Hvis man kaster et blik på
MVC-modellen set på figur \ref{fig:mvc}, kan man at der her kaldes fra viewet i
\texttt{.fxml} filen til controlleren. \texttt{MenuController} sætter derpå et
nyt view, \texttt{SearchResult.fxml}. Dette view skal vise resultaterne af
søgningen. Dette ses i nedenstående snippet. Der sættes også en ny controller,
til at administrere det nye view.

\begin{lstlisting}
setContentPane("SearchResult.fxml", (Object) SearchController.getInstance());
SearchController.getInstance().setContent();
\end{lstlisting}

Derpå kalder \texttt{SearchController},

\begin{lstlisting}
SearchList.setItems(ApplicationManager.getInstance().search(searchString));
\end{lstlisting}

hvorpå at \texttt{ApplicationManager} i domænelaget står for at facilitere
søgningen, ved at kalde de korrekte Managers for at lave søgningen. Her bliver
\texttt{PersonManager} kaldt, hvorefter den kalder på \texttt{Factory}, som står
for kommunikationen med persistenslaget (ved at kalde
\texttt{DatabaseLoaderFacade}), for at de korrekte dataobjekter bliver
instantieret med den returnerede data. 

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, firstnumber=31, caption=Forspørgsel til
persistenslaget og konstruktion af dataobjekter (\texttt{Factory.java})]
public ObservableList<IPerson> getPersons(String searchString) {
  ObservableList<IPerson> personObservableList 
    = FXCollections.observableArrayList();
    ResultSet personsResultSet 
        = DatabaseLoaderFacade.getInstance().searchPersonsFromDatabase(searchString);
    try {
        while (personsResultSet.next()) {
            IPerson tempPerson 
                = Mapper.getInstance().mapPerson(personsResultSet);
\end{lstlisting}

\texttt{DatabaseLoaderFacade}, kalder \texttt{DatabaseLoader} som queryer
databasen. Funktionen \texttt{searchQueryToPersonList} har
\texttt{package-private}(som er standard) indkapsling. Således at dens
funktionalitet kan anvendes af \texttt{DatabaseLoaderFacade}, men ikke kan
tilgås udenfor pakken. 

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, firstnumber=42,
caption=Query af databasen for personer (\texttt{DatabaseLoader.java})]
ResultSet searchQueryToPersonList(String searchString) {
  ArrayList<IPerson> personObservableList = new ArrayList<>();
  try {
    PreparedStatement queryStatement = getInstance().connection.prepareStatement(
      "SELECT * FROM credits, persons WHERE LOWER(name) LIKE LOWER(?) " +
        "AND credits.credit_id = persons.credit_id " /* +
        "AND jobs.person_id = persons.person_id " +
        "AND jobs.job_role_id = job_roles.job_role_id" */
    );
    queryStatement.setString(1, "%" + searchString + "%");
    queryStatement.executeQuery();

    return queryStatement.getResultSet();
\end{lstlisting}

Her i \texttt{DatabaseLoader} laves der en query til databasen, for personer
hvis navn ligner søgestrengen, samt hvilke jobs den fundne person har haft.





\subsubsection{Overholdelse af Model-View-Controller mønsteret} Hvordan sikrer gruppen at benytte sig effektivt af Model-View-Controller mønsteret? 
JavaFX library'et indeholer en typer af lister kaldet ObservableLists.
Observable lister fungerer som de flereste andre lister, og kan instantieres som
bl.a. en observable ArrayList. Det specielle ved ObservableLister er at man kan
tilføje "Listeners". Listeners er som navnet angiver, en enhed der kan "lytte"
efter ændringer på objekterne som listerne indeholder. Lad os sige brugeren får
præsenteret en liste af personer. Dette er viewet i modellen. Her vælger
brugeren så at godkende en person. Den handling registrerer en controller
(Controller i mønsteret) og i programmet kalder controlleren en funktion i
applicatioManager, der ænder noget data nede i databasen (Model i mønsteret). Da
denne liste har en listener på ændringer i data indeholdt i listen, notificerer
ændringen af data denne listener, som får viewet til at opdatere, så brugeren nu
ser det opdaterede data.  Tilføjelsen af en listener til en observableList kan
ske på følgende som det ses på figur \textbf{RET REFERENCE}

\begin{lstlisting}[caption = set]
    private void setContent(AnchorPane listToApprove, ObservableList
    <? extends ICredit> creditList){
        int offset = 20;
        for (ICredit credit : creditList){
            if (!credit.isApproved()) {
                addItem(listToApprove, credit, offset);
                offset += 30;
            }
        }

        creditList.addListener((ListChangeListener<ICredit>) change -> {
            int offset1 = 20;
            while (change.next()) {
                if (change.wasAdded()) {
                    for (ICredit credit : change.getAddedSubList()){
                        if (!credit.isApproved()){
                            addItem(listToApprove, credit, offset1);
                            offset1 += 30;
                        }
                    }
                } else if (change.wasRemoved()) {
                    for (ICredit credit : change.getRemoved()){
                        System.out.println("Removed credit: " + credit);
                        removeItem(listToApprove, credit);
                    }
                }
            }
        });
\end{lstlisting}




